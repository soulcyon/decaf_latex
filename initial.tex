% TODO 
% Sasahank's and Nakayama's environmental, repair transitions and numerical optimizations.
% Talk about environment dependent phis ? 

\documentclass[12pt]{article}
\author{M. Sanghavi, S. Tadepalli, M. Nakayama}
\date{January 2013}

\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{mathabx}

\newcommand{\VARNAME}[1]{\textrm{\it#1}}

\begin{document}

\title{Title Title Title}
\maketitle


\section{Algorithms}
\label{sec:alg}

We now provide highly optimized algorithms for generating all possible subTrees and updating the Q Matrix. Since the number of trees for a model is exponential, we generate each unique subTree and its corresponding superTree (also unique) only once. We iterate through the Q Matrix and update all transitions where the subTree is applicable. This is the tree based approach to filling in the Q Matrix, which is mentioned in the remark in Section 4.2 of the preceding paper. \cite{Iyer:2009} Generating subtrees only once ensures the bottleneck of tree generation in DECaF takes the least possible execution time. The superTree is represented by keeping a Breadth First History of the subtree. We also generate larger subTrees by adding one level at at time to already generated subTrees. This ensures that work done to generate an existing tree can be reused. By not starting at the root each time we need to generate a tree saves DECaf a tremendous amount of execution time. We make optimizations to other areas in DECaF as well. \\ 

Algorithm 1 SeedSubTrees starts the tree generation and initializes the necessary data structures for the recursion in Algorithm 2 AddSubTreeLevel. 

$\Gamma$ describes cascading failures with details about which components can cause which other components to fail. 
We start by iterating through the model's component set, \VARNAME{compSet} to choose a root component, \VARNAME{rootC} for an initial tree with one node. 

We then initialize the following data structures: \VARNAME{level}, a dynamic array to hold all the failed nodes in a level in breadth first order, \VARNAME{nFailed} a list that counts the number of failed components differentiated by type and \VARNAME{BFHist} a data structure that is the Breadth First History of a subTree. It is implemented as an array of linked lists indexed by component type that stores parents of both nodes, which did and did not fail in a subTree. \VARNAME{BFHist} plays the role of a superTree to calculate the complement rates of nodes that did not fail.

Since the root must fail, we add \VARNAME{rootC} to \VARNAME{level}. We use @ to denote when a component has failed. We add @ \VARNAME{BFHist} at the index of type \VARNAME{rootC}. We update \VARNAME{nFailed} as well by setting the counter for type \VARNAME{rootC} to 1.         

If a component cannot cause any other components to fail only the trivial subTree of one node can be made. We then evaluate and process this single-node subTree's rate because it cannot be grown further. Otherwise for all types of components that have a nonempty $\Gamma$, or equivalently, can cause other types of components to fail, we call AddSubTreeLevel to proceed with building larger subTrees.    

\begin{algorithm}
\caption{SeedSubTrees($\Gamma$)}
\label{alg:SeedSubTrees}
where $\Gamma$ is an ordered set that describes which components can cause which other components to fail\\
\begin{algorithmic}[1]
\FOR{\VARNAME{rootC} $\in$ \VARNAME{compSet}}
  \STATE \VARNAME{level} = [ ]; \COMMENT {dynamic array of failed components at subTree's current level}
  \STATE \VARNAME{nFailed} = $(0, 0, \ldots, 0)$; \COMMENT {counts failed components of each type}
  \STATE \VARNAME{BFHist} = $ ((\,), (\,), \ldots, (\,)) $; \COMMENT {an array of linked lists that keeps a breadth-first history of subTrees, array is indexed by component type, linked list for each component type stores parents in breadth-first order}
  %\STATE $\Gamma Cache = \{$Array of Size $2 ^{|\Gamma_{rootC}|}\};$ \COMMENT {Stores All Possible Subsets of $\Gamma_{rootC}$} 
  %\STATE % empty line %
  \STATE add \VARNAME{rootC} to \VARNAME{level};
  \STATE \VARNAME{nFailed}[\VARNAME{rootC}] = 1;
  %\STATE $\Gamma Cache_{rootC} = \mathcal{P}(\Gamma_{rootC});$ \COMMENT{Power Set (Ordered Set) is Cached}
  \STATE add @ to \VARNAME{BFHist}[\VARNAME{rootC}]; \COMMENT {signifies one component of type rootC has failed}
  \IF{(Empty($\Gamma_{\VARNAME{rootC}}$))}
    \STATE ComputeTreeRates(\VARNAME{nFailed}, \VARNAME{BFHist}, \VARNAME{subTreeRate}, \VARNAME{rootC});
  \ELSE
    \STATE AddSubTreeLevel(\VARNAME{level}, \VARNAME{nFailed}, \VARNAME{BFHist}, 1, \VARNAME{rootC});
  \ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{AddSubTreeLevel(\VARNAME{level}, \VARNAME{nFailed}, \VARNAME{BFHist}, \VARNAME{subTreeRate}, \VARNAME{rootC})}
\label{alg:AddSubTreeLevel}
where \VARNAME{level} describes failed components, \\\VARNAME{nFailed} counts failed components by type, \\\VARNAME{BFHist} is Breadth First History, \\\VARNAME{subTreeRate} is a cumulative probability of comps that failed, \\\VARNAME{rootC} is the root component of the current subtree \\
\begin{algorithmic}[1]
\STATE \VARNAME{nextLevelPossibilities} = $\bigtimes\limits_{i\,=\,1}^{|level|}\mathcal{P}(\Gamma_{level[i]});$
\\ \COMMENT{Builds set of all possible nodes in next level as Cartesian product of power sets of $\Gamma$'s}
  \FOR{\VARNAME{oneNextLevelPossibility} $\in$ \VARNAME{nextLevelPossibilities}}
    \STATE \VARNAME{addedChildFlag} = False;
    \FOR{\VARNAME{parentC} $\in$ \VARNAME{level}}
      \FOR{\VARNAME{childC} $\in$ $\Gamma_{\VARNAME{parentC}}$}
          \IF{\VARNAME{childC} $\in$ \VARNAME{oneNextLevelPossibility}}  
            \IF{\VARNAME{nFailed}[\VARNAME{childC}] == Redundancy(\VARNAME{childC})}
              \STATE goto line 3; 
              \COMMENT {invalid subtree, requires more comps than available in system}
            \ENDIF 
            \STATE \VARNAME{addedChildFlag} = True;
            \STATE \VARNAME{nFailed}[\VARNAME{childC}] = \VARNAME{nFailed}[\VARNAME{childC}] + 1;
            \STATE add @ to \VARNAME{BFHist}[\VARNAME{childC}]; \COMMENT {signifies one component of type childC has failed}
            \STATE $\VARNAME{subTreeRate} = \VARNAME{subTreeRate} * \phi_{parentC,\; childC};$ 
            \\ \COMMENT {update rate with $\phi$}
          \ELSE
           \STATE add \VARNAME{parentC} to \VARNAME{BFHist}[\VARNAME{childC}]; \COMMENT {signifies one component of type childC has not failed, but was present in $\Gamma_{\VARNAME{parentC}}$}
         \ENDIF
      \ENDFOR
    \ENDFOR
    %\STATE % empty line %
    \IF{\VARNAME{addedChildFlag}}
      \STATE AddSubTreeLevel(\VARNAME{oneNextLevelPossibility}, \VARNAME{nFailed}, \VARNAME{BFHist}, \VARNAME{subTreeRate}, \VARNAME{rootC}); 
      \\ \COMMENT {subTree can be grown further}
    \ELSE
      \STATE ComputeTreeRates(\VARNAME{nFailed}, \VARNAME{BFHist}, \VARNAME{subTreeRate}, \VARNAME{rootC});
      \\ \COMMENT {current subTree is completed because it cannot be grown further}
    \ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{ComputeTreeRates(\VARNAME{nFailed}, \VARNAME{BFHist}, \VARNAME{subTreeRate}, \VARNAME{rootC})}
\label{alg:computeTreeRates}
where \VARNAME{level} describes failed components, \\\VARNAME{nFailed} counts failed components by type, \\\VARNAME{BFHist} is Breadth First History, \\\VARNAME{subTreeRate} is a cumulative probability of comps that failed, \\\VARNAME{rootC} is the root component of the current subtree \\
\begin{algorithmic}[1]
\FOR{$\VARNAME{x'} \in \VARNAME{S'}$}
  \STATE $\VARNAME{prodNotFailedProb} = 1;$ \COMMENT{cumulative probability of comps that could have failed but did not}
  \FOR{$\VARNAME{comp} \in \VARNAME{compSet}$}
    \STATE $\VARNAME{compsAvailable} = \:$Redundancy$(\VARNAME{comp}) - \VARNAME{x}[\VARNAME{comp}];$
    \FOR{$\VARNAME{parentC} \in \VARNAME{BFHist}[\VARNAME{comp}]$}
      \IF{\VARNAME{parentC} == @}
        \STATE $\VARNAME{compsAvailable} = \VARNAME{compsAvailable} - 1;$
      \ELSIF {$\VARNAME{compsAvailable} > 0$} 
        \STATE $\VARNAME{prodNotFailedProb} = \VARNAME{prodNotFailedProb} * (1 - \phi_{parentC,\; comp});$
      \ENDIF
    \ENDFOR
  \ENDFOR
  %\STATE % empty line %
  \FOR{$\VARNAME{e} \in \VARNAME{envSet}$}
    \STATE Initialize \VARNAME{y} as a state with no components failed and environment \VARNAME{e};
    \FOR{\VARNAME{comp} $\in$ \VARNAME{compSet}}
    \STATE \VARNAME{y}[\VARNAME{comp}] = \VARNAME{x}[\VARNAME{comp}] + \VARNAME{nFailed}[\VARNAME{comp}];
    \ENDFOR
    % \STATE Environment$(\VARNAME{y}) = \:$Environment$(\VARNAME{x});$
    \IF{\VARNAME{y} is not a valid state}
    \STATE continue;
    \ENDIF
    % \STATE $\VARNAME{n} = \:$Redundancy$(\VARNAME{rootC}) - \VARNAME{x}[\VARNAME{rootC}];$
    % \STATE $\VARNAME{rootFailureRate} = \VARNAME{n} * \lambda_{\VARNAME{rootC},\; \VARNAME{env}}\,;$
    \STATE $\VARNAME{rootFailureRate} = \:($Redundancy$(\VARNAME{rootC}) - \VARNAME{x}[\VARNAME{rootC}]) * \lambda_{\VARNAME{rootC},\; \VARNAME{e}}\,;$
  \ENDFOR
  \STATE $\VARNAME{Q}(\VARNAME{x},\VARNAME{y}) = \VARNAME{Q}(\VARNAME{x},\VARNAME{y}) + \VARNAME{rootFailureRate} * \VARNAME{subTreeRate} * \VARNAME{prodNotFailedProb};$
\ENDFOR
\end{algorithmic}
\end{algorithm}
\end{document}