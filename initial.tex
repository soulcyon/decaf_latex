%
% TODO
% Sashank's and Nakayama's environmental, repair transitions and numerical optimizations (U/D states).
% Talk about environment dependent phis in Remarks?
% Cache for BFH Eval
%

\documentclass[12pt]{article}
\author{M. Sanghavi, S. Tadepalli, M. Nakayama}
\date{January 2013}

\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{mathabx}
\usepackage[left = 1.0in, top = 1in, right = 1.0in, bottom = 1in, nohead]{geometry}

\newcommand{\captionAmerica}[2]{
\noindent\hspace{\fill}\rule{1.0\linewidth}{.7pt}\hspace{\fill}\vspace{-0.25em}\\*\raggedright\textbf{Algorithm #1} #2 \vspace{-0.8em}\\*\hspace{\fill}\rule{1.0\linewidth}{.7pt}\hspace{\fill}
}
\newcommand{\varName}[1]{\textrm{\it#1}}
\newcommand{\citeLine}[1]{$\{\,#1\,\}$}
\newcommand{\citeBlock}[2]{$\{\,#1 - #2\,\}$}

\begin{document}
\title{Working Title}
\maketitle

% \section{Introduction}

% \section{Model}

\section{Algorithms}
\label{sec:alg}

We now provide efficient algorithms for generating all possible trees and updating the $Q$-matrix. A tree corresponds to a set of particular components failing, and cascading failures starting from different states can have the same set of components failing. Hence, a particular tree may correspond to several different transitions. Our algorithm generates each possible tree only once and determines all the transitions to which this tree corresponds.  This avoids generating the same tree numerous times, as was originally done in \cite{}.  Because the number of trees grows exponentially in the number of components in the model, our current algorithm significantly reduces the total computational effort. Moreover, rather than building each new tree from scratch, as was done in \cite{}, our current algorithm builds larger trees from smaller ones already considered, leading to additional savings in the computation. 

Computing the rate of a given tree depends on the state from which the cascading failure began and the set of components that fails in the cascade. Each component $i$ can possibly cause any subset of components from a set $\Gamma_i$ to simultaneously fail when $i$ fails; i.e., not all components in $\Gamma_i$ actually fail in a given cascade. We also consider the supertree from a given tree by adding in the components that did not fail from the $\Gamma_i$ that were used, which is necessary to compute the rate of a tree. We do not actually build the supertree in our algorithm, but instead build a \textit{breadth-first history} to keep track of the information necessary to compute a tree's rate. A breadth-first history accounts for the contribution to the tree's rate of the components that could have failed (i.e., belong to the set $\Gamma_i$ of a node of type $i$ that actually did fail), but did not. We explain the process of building a breadth-first history and using it to compute the rate of a tree in Algorithms 2 (AddTreeLevel) and 3 (ComputeTreeRate), respectively.

SeedTrees (Algorithm 1), starts the tree generation and initializes the necessary data structures for AddTreeLevel (Algorithm 2). AddTreeLevel adds a new level to an existing tree in a recursive fashion, updates the cumulative failed probability for the tree for the components that actually failed as well as builds the tree's breadth-first history. ComputeTreeRate computes the rate of a completed tree for all the transitions it corresponds to using the cumulative failed probability and the breadth-first history populated in AddTreeLevel. We will now discuss each algorithm in detail. Line numbers from each the algorithms are given in their corresponding texts within braces \citeLine{}.

\subsection{SeedTrees}

Cascading failures per component are described in $\Gamma$, which is an array of sets of component types. Each $\Gamma_i$ is the set of component types that can be caused to fail when a component type $i$ fails. We start by iterating through \textit{compSet}, the set of all component types, to choose a root component, \textit{rootC}, for an initial tree with one node \citeLine{1}. We then initialize the following data structures: \textit{level}, a dynamic array to hold all the failed nodes in the current bottom level (in breadth-first order); \textit{nFailed}, a list that counts the number of failed components of each type in the tree; and \textit{BFHist}, a data structure that is the breadth-first history of a tree. \textit{BFHist} is implemented as an array of linked lists indexed by component type. Each linked list stores the respective parents of nodes exclusive to the supertree (i.e., the nodes that \textit{did not} fail but could have provided their component type's redundancy was not exhausted) and stores the symbol @ for the nodes that \textit{did} fail in the tree. \textit{BFHist} plays the role of a supertree in determining whether to include the complement probabilities of nodes that did not fail. A complement probability is included for a node that did not fail only if there are still components of the type available in the system at that point. The number of available components of a type is given by the redundancy of the component type minus the number failed in the ``from'' state, minus the number failed in the tree thus far in breadth-first order \citeBlock{2}{4}. For a transition $(x,y)$, we define the ``from'' state as $x$, and the ``to'' as $y$.

Since the root must fail, we initialize \textit{level} with \textit{rootC}. We add the symbol @ to \textit{BFHist} at the index of type \textit{rootC} to denote that the root has failed. We update \textit{nFailed} by setting the counter for \varName{rootC's} type to 1 \citeBlock{5}{7}.

If the component \textit{rootC} at the root cannot cause any other components to fail, only the trivial tree of one node can be made with this type of root. We then evaluate this single-node tree's rate in ComputeTreeRate because it cannot be grown further. If $\Gamma_{\textrm{\textit{rootC}}} \neq \emptyset$, i.e., it can cause other types of components to fail, then we call AddTreeLevel to proceed with building taller trees by adding another level to the current tree \citeBlock{8}{13}.

In treeRate we only keep track of the cumulative product of the component-affected probabilities $\phi_{i,j}$ for the transition rate of the tree, which entails multiplying $\phi_{i, j}$ for all edges from parent \varName{i} to child \varName{j} in the tree. The total transition rate of a completed tree consists of three parts: the failure rate of the root, the treeRate and the cumulative product of the complement probabilities of components that could have failed. The failure rate of the root is given by the $n*\lambda_{rootC, \,e}$ term, where $n$ is the number of components up in the system of the type of \varName{rootC} and $\lambda_{rootC, \,e}$ is the failure rate of the type of \varName{rootC} in environment $e$. The cumulative product of complement probabilities consists of products of the form $1-\phi_{i, j}$ for all edges from parent \varName{i} to child \varName{j} in the tree, where failures did not occur but could have because of components of type \varName{j} were still up. We multiply the $1-\phi_{i,j}$ terms and the $n*\lambda_{rootC, \,e}$ later in ComputeTreeRate as they depend on the ``from" state of the failure transition. Since the tree has only one node, there are no failed nodes from a cascade (i.e., nodes have been caused to fail by other nodes). Hence, we pass 1 as the value for treeRate to the subroutines AddTreeLevel and ComputeTreeRate.
\\*\\*\\*

\captionAmerica{1}{SeedTrees($\Gamma$)}
where $\Gamma$ is an array of ordered sets that describes which components can cause which other components to fail
\\*\vspace{0.8em}
\begin{algorithmic}[1]
\FOR{\varName{rootC} $\in$ \varName{compSet}}
  \STATE \varName{level} = [ ]; \COMMENT {dynamic array of failed components at tree's current bottom level}
  \STATE \varName{nFailed} = $(0, 0, \ldots, 0)$; \COMMENT {counts failed components of each type in the tree}
  \STATE \varName{BFHist} = $ ((\,), (\,), \ldots, (\,)) $; \COMMENT {an array of linked lists that keeps a breadth-first history of trees, array is indexed by component type, linked list for each component type stores parents in breadth-first order}
  %\STATE $\Gamma Cache = \{$Array of Size $2 ^{|\Gamma_{rootC}|}\};$ \COMMENT {Stores All Possible Subsets of $\Gamma_{rootC}$} 
  %\STATE % empty line %
  \STATE add \varName{rootC} to \varName{level};
  \STATE \varName{nFailed}[\varName{rootC}] = 1;
  %\STATE $\Gamma Cache_{rootC} = \mathcal{P}(\Gamma_{rootC});$ \COMMENT{Power Set (Ordered Set) is Cached}
  \STATE add @ to \varName{BFHist}[\varName{rootC}]; \COMMENT {signifies one component of type rootC has failed}
  \IF{Empty($\Gamma_{\varName{rootC}}$)}
    \STATE ComputeTreeRate(\varName{nFailed}, \varName{BFHist}, \varName{treeRate}, \varName{rootC});
  \ELSE
    \STATE AddTreeLevel(\varName{level}, \varName{nFailed}, \varName{BFHist}, 1, \varName{rootC});
  \ENDIF
\ENDFOR
\end{algorithmic}

\subsection{AddTreeLevel}

In AddTreeLevel, given a tree, we determine all the possibilities for the next level that can be added to the current tree by taking the Cartesian product of the power sets of $\Gamma$ for each of the failed components at the current bottom level. For each next level we recursively call AddTreeLevel. We use $\mathcal{P}$ to denote the power set-like operation on an ordered set. In our realization of the power set operation, components in each subset maintain their relative ordering from the original set.

We implement this power set-like operation by generating all possible binary numbers with $\sum\limits_{i\,=\,1}^{|level|}\Gamma_{level[i]}$ bits. A total of $\prod\limits_{i\,=\,1}^{|level|}2^{\Gamma_{level[i]}}$ such binary numbers are generated. In the binary number, 1 denotes a failed node, 0 denotes a node that could have failed but did not fail. If it so happens that we have a tree where none of the leaf nodes at the current bottom level can cause any other components to fail (i.e., have empty $\Gamma$s), we get no nextLevelPossibilities \citeLine{1}. If there are no nextLevelPossibilities we immediately proceed to ComputeTreeRate \citeBlock{2}{4}.

Otherwise, we choose one possible choice for the failed components in the next level to work with from the nextLevelPossibilities \citeLine{5}. To find out whether any new children will be added in the upcoming next level, we create a Boolean variable \textit{addedChildFlag}, initially with the value of False \citeLine{6}. For each node \textit{parentC} in the current bottom level that acts as a parent, potentially causing other nodes to fail, we iterate through all of its possible children, i.e., through its $\Gamma$. If any of these children actually fail, then they will be members of the set \textit{oneNextLevelPossibility} \citeBlock{7}{9}. Now if the redundancy of the component type we just tried to add as a child has already been exhausted, it cannot fail and hence our tree is invalid and we move on to the next possibility \citeBlock{10}{12}.

If it is indeed possible to add a child of the type of \textit{childC} we flag this occurrence and update the relevant data structures. We add 1 to \textit{nFailed} at the index of type \textit{childC}. We add the symbol @ to \textit{BFHist} at the index of type \textit{childC} to mark that a failure has occurred at this location in the tree. We update tree rate with the component-affected probability of the parent causing the child to fail \citeBlock{13}{16}. If the child does not actually fail but could have (because there are still operational components of the child's type at this point), then we add \textit{parentC} to \textit{BFHist}, at the index of the type of the child. \textit{BFHist} comes in use later in ComputeTreeRate, to determine when to multiply the current tree rate with the $1-\phi_{i,j}$ terms for the components that did not fail but could have \citeBlock{17}{19}.

We do the above updates to data structures for each potential parent node in \textit{level} and each of its children in \textit{oneNextLevelPossibility} \citeBlock{7}{21}. If at least one child has been added, we add another level to the current tree \citeBlock{22}{23}. Otherwise, this tree has not changed in this pass through AddTreeLevel and we call ComputeTreeRate to compute the rate of the finalized tree \citeBlock{24}{26}. We make sure that trees are not double counted because once a tree passes through AddTreeLevel unmodified, it is processed and discarded. We do not make duplicate trees because each oneNextLevelPossibility is unique.

\captionAmerica{2}{AddTreeLevel(\varName{level}, \varName{nFailed}, \varName{BFHist}, \varName{treeRate}, \varName{rootC})}
where \varName{level} describes failed components, \\*\varName{nFailed} counts failed components by type, \\*\varName{BFHist} is breadth-first history, \\*\varName{treeRate} is a cumulative probability of components that failed, \\*\varName{rootC} is the root component of the current tree
\\*\vspace{0.8em}
\begin{algorithmic}[1]
\STATE \varName{nextLevelPossibilities} = $\bigtimes\limits_{i\,=\,1}^{|level|}\mathcal{P}(\Gamma_{level[i]});$
\\*\COMMENT{Builds set of all possible nodes in next level as Cartesian product of power sets of $\Gamma$s}
  \IF{Empty(\varName{nextLevelPossibilities})}
    \STATE ComputeTreeRate(\varName{nFailed}, \varName{BFHist}, \varName{treeRate}, \varName{rootC});
    \\*\COMMENT {current tree cannot be grown further because its leaf nodes at the current bottom level have empty $\Gamma$}
  \ENDIF
  \FOR{\varName{oneNextLevelPossibility} $\in$ \varName{nextLevelPossibilities}}
    \STATE \varName{addedChildFlag} = False;
    \FOR{\varName{parentC} $\in$ \varName{level}}
      \FOR{\varName{childC} $\in$ $\Gamma_{\varName{parentC}}$}
          \IF{\varName{childC} $\in$ \varName{oneNextLevelPossibility}}  
            \IF{\varName{nFailed}[\varName{childC}] == Redundancy(\varName{childC})}
              \STATE goto line 3; 
              \COMMENT {invalid tree, requires more components than available in system}
            \ENDIF
            \STATE \varName{addedChildFlag} = True;
            \STATE \varName{nFailed}[\varName{childC}] = \varName{nFailed}[\varName{childC}] + 1;
            \STATE add @ to \varName{BFHist}[\varName{childC}]; \COMMENT {signifies one component of type childC has failed}
            \STATE $\varName{treeRate} = \varName{treeRate} * \phi_{parentC,\; childC};$ 
            \\*\COMMENT {update rate with component-affected probability}
          \ELSE
           \STATE add \varName{parentC} to \varName{BFHist}[\varName{childC}]; \COMMENT {signifies one component of type childC has not failed, but was present in $\Gamma_{\varName{parentC}}$}
         \ENDIF
      \ENDFOR
    \ENDFOR
    %\STATE % empty line %
    \IF{\varName{addedChildFlag}}
      \STATE AddTreeLevel(\varName{oneNextLevelPossibility}, \varName{nFailed}, \varName{BFHist}, \varName{treeRate}, \varName{rootC}); 
      \\*\COMMENT {tree can be grown further}
    \ELSE
      \STATE ComputeTreeRate(\varName{nFailed}, \varName{BFHist}, \varName{treeRate}, \varName{rootC});
      \\*\COMMENT {current tree is completed because it cannot be grown further}
    \ENDIF
\ENDFOR
\end{algorithmic}


\subsection{ComputeTreeRate}

In ComputeTreeRate, for a given tree, we determine all of the transitions $(x,y)$ in the $Q$-matrix that use this tree, and then update  the total rates of each of those transitions $(x,y)$ by adding in the rate of the current tree to the current rate for $(x,y)$. However, even if several transitions use the same tree, the rate of the tree may differ for those transitions, so we need to compute a separate tree rate for each transition. The failure rate of the root and cumulative product of complement probabilities are transition dependent, leading to different rates for the same tree shared by multiple transitions.

Let $x'$ be a particular ``from" state's failed component types count (which is independent of environment) from the state space $S'$ (also independent of environment) \citeLine{1}. The variable \textit{prodNotFailedProb} denotes the product of the complement probabilities of all the nodes in the tree that did not fail, but could have provided their component type's redundancy had not been exhausted \citeLine{2}. For each component type in $x'$, for each component type we calculate the number of components by type that are available in the system as redundancy minus the number already failed in the ``from" state. The number \textit{compsAvailable} determines until which point, while traversing through the \textit{BFHist}, we can still have components of a certain type that could have failed but did not fail \citeLine{4}. We cannot have components that \textit{could have failed but did not} after a point in the tree where their type has been exhausted. A type is exhausted when the total number of failed components of the type in the system, i.e. the sum of the components failed in the ``from" state and in the tree in breadth-first order until the current node, equals the redundancy of the type. Each time we encounter the symbol @ in the \textit{BFHist}, we reduce the number available by one \citeBlock{5}{7}. If there are components still available, we update \textit{prodNotFailedProb} \citeBlock{8}{9}. As soon as \textit{compsAvailable} reaches zero, we break because that type has then been exhausted and hence there are no more could have failed for the type \citeBlock{10}{12}.

Once we have finished calculating the \textit{prodNotFailedProb}, we loop through all environments since the same tree can be used for transitions occurring in different environments. \citeLine{15}. We generate ``from" states by adding an environment \textit{e} to $x'$. from We generate ``to" states \textit{y} (with an environment \textit{e}) by adding \textit{nFailed} to $x'$ \citeBlock{16}{20}. Invalid ``to" states will be generated in some instances, because simply adding \textit{nFailed} will cause component types' number failed to exceed their redundancy. \citeBlock{21}{23}. The failure rate of the root is calculated as the number of components of the \varName{rootC}'s type up in the system, multiplied by the failure rate of the component in the environment of y.\citeLine{24}. With all parts of the rate calculation done, we update the failure transition's cell in the $Q$-matrix with the tree rate \citeLine{26}.

\captionAmerica{3}{ComputeTreeRate(\varName{nFailed}, \varName{BFHist}, \varName{treeRate}, \varName{rootC})}
where \varName{level} describes failed components, \\\varName{nFailed} counts failed components of each type in the tree, \\\varName{BFHist} is breadth-first history, \\\varName{treeRate} is a cumulative probability of components that failed, \\\varName{rootC} is the root component of the current tree
\\*\vspace{0.8em}
\begin{algorithmic}[1]
\FOR{$x' \in S'$}
  \STATE $\varName{prodNotFailedProb} = 1;$ \COMMENT{cumulative product of complement probabilities of components that could have failed but did not}
  \FOR{$\varName{comp} \in \varName{compSet}$}
    \STATE $\varName{compsAvailable} = \:$Redundancy$[\varName{comp}] - \varName{x}[\varName{comp}];$
    \FOR{$\varName{parentC} \in \varName{BFHist}[\varName{comp}]$}
      \IF{\varName{parentC} == @}
        \STATE $\varName{compsAvailable} = \varName{compsAvailable} - 1;$
      \ELSIF {$\varName{compsAvailable} > 0$}
        \STATE $\varName{prodNotFailedProb} = \varName{prodNotFailedProb} * (1 - \phi_{parentC,\; comp});$
      \ELSE
        \STATE break;
        \COMMENT{compsAvailable must equal 0 which means there cannot be any more nodes that could have failed of the type of comp}
      \ENDIF
    \ENDFOR
  \ENDFOR
  %\STATE % empty line %
  \FOR{$\varName{e} \in \varName{envSet}$}
    \STATE Initialize \varName{x} as a state with $x'$ of components failed and environment \varName{e};
    \STATE Initialize \varName{y} as a state with no components failed and environment \varName{e};
    \FOR{\varName{comp} $\in$ \varName{compSet}}
    \STATE \varName{y}[\varName{comp}] = \varName{x}[\varName{comp}] + \varName{nFailed}[\varName{comp}];
    \ENDFOR
    % \STATE Environment$(\varName{y}) = \:$Environment$(\varName{x});$
    \IF{\varName{y} is not a valid state}
    \STATE continue;
    \ENDIF
    % \STATE $\varName{n} = \:$Redundancy$(\varName{rootC}) - \varName{x}[\varName{rootC}];$
    % \STATE $\varName{rootFailureRate} = \varName{n} * \lambda_{\varName{rootC},\; \varName{env}}\,;$
    \STATE $\varName{rootFailureRate} = \:($Redundancy$[\varName{rootC}] - \varName{x}[\varName{rootC}]) * \lambda_{\varName{rootC},\; \varName{e}}\,;$
  \ENDFOR
  \STATE $\varName{Q}(\varName{x},\varName{y}) = \varName{Q}(\varName{x},\varName{y}) + \varName{rootFailureRate} * \varName{treeRate} * \varName{prodNotFailedProb};$
\ENDFOR
\end{algorithmic}

\section{Experimental}
\subsection{Nested Experimental}

\bibliographystyle{ieeetr}
\bibliography{mkn}
\end{document}